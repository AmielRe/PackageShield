package com.amiel.packageshield.services;

import com.amiel.packageshield.models.SecurityVulnerabilities;
import com.amiel.packageshield.models.Dependency;
import com.amiel.packageshield.models.VulnerableDependency;
import com.github.zafarkhaja.semver.Version;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.graphql.client.GraphQlClient;
import org.springframework.graphql.client.HttpGraphQlClient;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;

@Service
public class GithubVulnerabilityScanner implements VulnerabilityScanner {

    @Value("${graphqlApiUrl}")
    private String graphqlApiUrl;

    GraphQlClient client;

    @Value("${GITHUB_ACCESS_TOKEN}")
    private String GITHUB_ACCESS_TOKEN;

    @PostConstruct
    void init() {
        WebClient wc = WebClient.builder()
                .baseUrl(graphqlApiUrl)
                .defaultHeader(HttpHeaders.AUTHORIZATION, "Bearer " + GITHUB_ACCESS_TOKEN).build();
        client = HttpGraphQlClient.create(wc);
    }

    /**
     * Query GitHub graphql api for security vulnerabilities of a package.
     * @param packageName The name of the package to scan
     * @param ecoSystem The ecosystem to check for
     * @return {@link SecurityVulnerabilities} Object which represents GitHub api result
     */
    private SecurityVulnerabilities queryApi(final String packageName, final String ecoSystem) {
        final String query = """
        query($packageName: String!, $ecosystem: SecurityAdvisoryEcosystem!) {
            securityVulnerabilities(ecosystem: $ecosystem, first: 100, package: $packageName) {
                nodes {
                    severity
                    vulnerableVersionRange
                    firstPatchedVersion {
                        identifier
                    }
                }
            }
        }""";

        // Insert the packageName as variable, retrieve the data from API and convert to 'SecurityVulnerabilities'
        return client.document(query)
                .variable("packageName", packageName)
                .variable("ecosystem", ecoSystem.toUpperCase())
                .retrieve("securityVulnerabilities").toEntity(SecurityVulnerabilities.class).block();
    }

    /**
     * Get vulnerabilities using GitHub api and checks if it's relevant for the dependency version
     * @param packageToCheck Dependency we want to check vulnerabilities
     * @param ecoSystem The ecosystem we are checking this dependency for
     * @return if vulnerability exists - {@link VulnerableDependency} object that represents the details
     * of the VulnerableDependency; else - return null
     */
    public VulnerableDependency checkDependencyForVulnerability(final Dependency packageToCheck, final String ecoSystem) {
        SecurityVulnerabilities vulnerabilities = queryApi(packageToCheck.getName(), ecoSystem);

        // Iterate over the nodes and extract the required data
        for (SecurityVulnerabilities.Node node : vulnerabilities.getNodes()) {
            if(isVersionInRange(packageToCheck.getVersion(), node.getVulnerableVersionRange())) {

                // Create VulnerablePackage object
                return new VulnerableDependency(packageToCheck.getName(),
                        packageToCheck.getVersion(),
                        node.getSeverity(),
                        node.getFirstPatchedVersion().getIdentifier());
            }
        }

        return null;
    }

    /**
     * Gets version range and version, checks if the version in version range
     * This is using "com.github.zafarkhaja.semver" library, the best i've found for
     * this case and version pattern
     * @param version The version we want to check if found in version range
     * @param versionRange The range of versions
     * @return True - version in version range; False otherwise
     */
    public static boolean isVersionInRange(String version, String versionRange) {
        Version v = Version.valueOf(version);
        return v.satisfies(versionRange.replace(',', '&'));
    }
}
